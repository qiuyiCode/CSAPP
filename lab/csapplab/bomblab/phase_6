phase_6过程：
1.栈开50字节空间（4010fc）
2.栈顶指针给%r13和%rsi（401100和401103）
3.读入六个数字(1 2 3 4 5 6)（401106）
4.栈顶指针给%r14（40110b）
5.%r12寄存器的低32位%12d赋0（40110e）

6.将%r13存储的值(数组指针移动后的值)赋给%rbp（401114）
7.将0x0(%r13)内存地址的值(即数组指针移动后的值)赋给%eax（401117）
8.%eax中的值减1后与值5比较,(%eax - 1) <= 5,程序正常运行(跳转401128),否则启动炸弹（40111e和401121）
9.%r12d的值加1,与6比较,(%12d = %12d + 1).若等于6,跳转401153,否则继续向下运行（401130）
10.假设此为第9步继续运行,%r12d的值赋给%rbx的低32位即%ebx（401132）

11.将%ebx中的值符号拓展后的双字送入四字（movslq）到%rax（401135）
12.将(%rsp,%rax,4),以栈顶为基址,向前移动%rax个整数大小的地址空间,并将值送入%eax（401138）
13.比较%eax与0x0(%rbp)的大小关系,不相等则跳转401145,否则引爆炸弹（40113e和401140）
14.假设此为第13步中不相等后继续运行,%ebx = %ebx + 1后与5比较,(%ebx + 1 <= 5)则跳转到（401135）继续执行（401145-40114b）

15.上面11-14的循环完毕,(%r13 = %r13 + 4)后跳转401114（40114d和401151）,这条指令后为401153（第9步等于6跳转）
16.假设此为第15步中跳转401114的情况,从数组的第二个数字开始循环上述过程,应为每个数字不能与后面的数字重复

17.假设此为第9步中(%r12d + 1) = 6的情况,取0x18(%rsp)送入%rsi,定位到输入数字尾巴的后一个的地址（401153）
18.将%r14的值（栈顶地址）赋给%rax（401158）

(将输入的六个数字x分别做7-x后放入栈中)
19.将立即数7赋给%ecx,将%ecx中的值(立即数7)赋给%edx（40115b和401160）
20.sub (%rax),%edx,将(%edx = %edx - 输入数字的值)（401162）
21.将得到的值%edx送入栈空间（401164）
22.%rax = %rax + 4,向前移动一位,并比较%rax与%rsi的值是否相等(是否遍历完了所有的输入元素),不相等则跳转401160.（401166、40116a、40116d）

23.上述循环完毕,继续执行.将立即数值0赋给%esi,跳转到地址401197（40116f和401174）
24.寻址(%rsp,%rsi,1)的内容(输入的6个值中的一个)赋给%ecx并与1比较,若%ecx <= 1,跳转到401183（40119d）
25.假设24步骤中%ecx > 1,顺序执行,将立即数1赋值给%eax,立即数0x6032d0赋值给%edx，跳转401176（40119f、4011a4、4011a9）
26.将0x8(%rdx)这个地址值(符号表中为node1)赋给%rdx（401176）应该是next的意思
27.%eax = %eax + 1,比较%ecx与%eax的大小,若不相等跳转401176,若相等跳转401188（40117a、40117d、70117f）（这段程序从1开始找到输入的6个数字中的一个,然后按照顺序将这些节点放入栈中）

28.假设27中%ecx与%eax的大小相等,执行地址401188处的程序,将%rdx所存储的地址值赋给0x20(%rsp,%rsi,2)处（401188）
29.%rsi = %rsi + 4,若%rsi == 0x18,跳转4011ab.（40118d、401191）
30.假设29步骤中%rsi不等于0x18,将(%rsp,%rsi,1)中的值(应为输入值的第二个值)赋给%ecx,若%ecx <= 1,跳转401183（401197、40119a、40119d）

31.仍假设%ecx > 1,顺序执行,将立即数1赋值给%eax,立即数0x6032d0赋值给%edx,跳转401176,重复步骤26的过程,直到将0x6032d0的6个地址全部放入栈中（40119f、4011a4、4011a9）

32.将栈中存储六个节点的首地址值赋给%rbx,第二个节点的地址给%rax,将0x50(%rsp)送入%rsi（4011ab、4011b0、4011b5）
33.将%rbx的值(此时为六个节点的首地址)送入%rcx,寻址%rax(遍历节点的地址)的内容送入%rdx,将%rdx送入0x8(%rcx)（应该是第一个节点指向第二个节点）（4011ba、4011bd、4011c0）
34.%rax = %rax + 8,%rsi与%rax比较,若未遍历完毕所有节点,将%rdx的值送入%rcx,跳转4011bd（应该是将栈中的节点链接起来）（4011c4、4011c8）

35.%rax与%rsi相等,遍历完成,跳转4011d2.将立即数0送入0x8(%rdx),尾节点的下一个节点为0（4011d2）
36.立即数5赋值给%ebp,将0x8(%rbx)的值(栈中保存的第二个节点的地址值)赋给%rax,在内存中寻找节点,(低32位)赋值给%eax，比较栈中保存的节点值与%eax的值的大小,若栈中保存的值大于等于%eax的值（栈中的值应该保证根据node给出的优先级为同一个顺序）,跳转4011ee,否则引爆炸弹（4011da、4011df、4011e3、1011e5、4011e7）

37.执行4011ee,mov 0x8(%rbx),%rbx,指向栈中的下一个节点,%ebp = %ebp - 1,未完成遍历则跳转4011df
